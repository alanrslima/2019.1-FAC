.data

	first_number: .word 0
	second_number: .word 0
	first_output: .asciiz "Informe o primeiro numero, menor que 255: "
	second_output: .asciiz "Informe o segundo numero, menor que 255: "
  print_div: .asciiz "========"
	add_output: .asciiz "\nADD: "
	sub_output: .asciiz "\nSUB: "
	and_output: .asciiz "\nAND: "
	or_output: .asciiz "\nOR: "
	xor_output: .asciiz "\nXOR: "
	sll_output: .asciiz "\nSLL(3): "
	srl_output: .asciiz "\nSRL(1): "
	error: .asciiz "\nNúmeros maiores que 255 não sao suportados!\nExecução encerrada!"

.text

main:
	# AA and BB, AA or BB, AA xor BB, AA sub BB, AA << 3,  BB >> 1
	
	li $v0,4 # Chamada de sistema para print de string
	la $a0,first_output # Printa o que está em first_output
	syscall
	li $v0,5 # Leitura de um valor inteiro de input
	syscall
	sw $v0, first_number # Salva o restorno na variavel first_number
	lw $t0, first_number # Carrega o que está em first_number para variavel de argumento
	slti $t1, $t0, 255  # Condicional, retorna True se $t0 < 255 e False se $t0 > 255
	beq $t2, $t1, exit_error #Se t2 for False, sai do programa
	move $s0, $t0 # Copia o que está em first_number para variavel de argumento
	
	li $v0,4 # Chamada de sistema para print de string
	la $a0,second_output # Printa o que está em second_output
	syscall
	li $v0,5 # Leitura de um valor inteiro de input
	syscall
	sw $v0, second_number # Salva o restorno na variavel first_number
	lw $t0, second_number # Carrega o que está em second_number para variavel de argumento
	slti $t1, $t0, 255  # Condicional, retorna True se $t0 < 255 e False se $t0 > 255
	beq $t2, $t1, exit_error #Se t1 for False, sai do programa
	move $s1, $t0 # Copia o que está em second_number para variavel de argumento
	
	# Realização das operacoes
	add $t0, $s0, $s1 # first_number + second_number = X 
	sub $t1, $s0, $s1 # first_number - second_number = X
	and $t2, $s0, $s1 # Bitwise first_number . second_number = X
	or $t3, $s0, $s1 # Bitwise first_number + second_number = X
	xor $t4, $s0, $s1 # Bitwise (first_number and ~second_number) = X
	sll $t5, $s0, 3 # Desloca 3 bits para esquerda em first_number
	srl $t6, $s1, 1 # Desloca 1 bit para direita em second_number
	
	jal print_data # Printa em tela os resultados da operações salvos de $t0 a $t6

	j exit # Saida do programa
	

exit:
	li $v0, 10 # exit
	syscall	
	

exit_error:
	li $v0, 4 # Chamada de sistema para print de string
	la $a0, error # Printa na tela a mensagem de erro
	syscall
	li $v0, 10 # Saida
	syscall
	
	
print_data:
  la $a0, print_div
	li $v0, 4 # Chamada de sistema para print de string
	syscall

  # ADD
	la $a0, add_output
	li $v0, 4 #Chamada de sistema para print de string
	syscall
	li $v0, 1 #Chamada de sistema para print de valor
	move $a0, $t0
	syscall

  # SUB
	la $a0, sub_output
	li $v0, 4 #Chamada de sistema para print de string
	syscall
	li $v0, 1 #Chamada de sistema para print de valor
	move $a0, $t1
	syscall
	
  # ADD
	la $a0, add_output
	li $v0, 4 #Chamada de sistema para print de string
	syscall
	li $v0, 1 #Chamada de sistema para print de valor
	move $a0, $t2
	syscall
	
  # OR
	la $a0, or_output
	li $v0, 4 #Chamada de sistema para print de string
	syscall
	li $v0, 1 #Chamada de sistema para print de valor
	move $a0, $t3
	syscall
	
  # XOR
	la $a0, xor_output
	li $v0, 4 #Chamada de sistema para print de string
	syscall
	li $v0, 1 #Chamada de sistema para print de valor
	move $a0, $t4
	syscall

  # SLL
	la $a0, sll_output
	li $v0, 4 #Chamada de sistema para print de string
	syscall
	li $v0, 1 #Chamada de sistema para print de valor
	move $a0, $t5
	syscall

  # SRL
	la $a0, srl_output
	li $v0, 4 #Chamada de sistema para print de string
	syscall
	li $v0, 1 #Chamada de sistema para print de valor
	move $a0, $t6
	syscall
	
	jr $ra